<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tao one hacker</title>
  
  <subtitle>Tao one hacker</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://iteverydaybro.github.io/"/>
  <updated>2019-12-09T09:30:43.738Z</updated>
  <id>https://iteverydaybro.github.io/</id>
  
  <author>
    <name>Tao one hacker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu18.04 配置root账户登录</title>
    <link href="https://iteverydaybro.github.io/2019/12/09/Linux-One/"/>
    <id>https://iteverydaybro.github.io/2019/12/09/Linux-One/</id>
    <published>2019-12-09T08:28:13.000Z</published>
    <updated>2019-12-09T09:30:43.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章说明"><a href="#文章说明" class="headerlink" title="文章说明"></a>文章说明</h2><p>本文主要介绍了在mac安装的Ubuntu虚拟机上，设置root密码，启用root账号。<br>默认情况下root账户并没有启用<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qkwwsyxkj30xi0hwq6m.jpg" alt><br>需要以下几个步骤</p><pre><code>1.设置root密码2.切换root账户3.修改/etc/pam.d/gdm-autologin4.修改/etc/pam.d/gdm-password5.修改/root/.profile5.重启系统</code></pre><h2 id="设置root密码"><a href="#设置root密码" class="headerlink" title="设置root密码"></a>设置root密码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qkzz9dldj31ao090tbo.jpg" alt></p><h2 id="切换root账户"><a href="#切换root账户" class="headerlink" title="切换root账户"></a>切换root账户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - root</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ql1xj4c7j314m06qmyy.jpg" alt></p><h2 id="修改-etc-pam-d-gdm-autologin"><a href="#修改-etc-pam-d-gdm-autologin" class="headerlink" title="修改/etc/pam.d/gdm-autologin"></a>修改/etc/pam.d/gdm-autologin</h2><p>注释掉auth required  pam_success_if.so user != root quiet_success</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/pam.d/gdm-autologin</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ql3k1dmjj314w0rak1l.jpg" alt></p><h2 id="修改-etc-pam-d-gdm-password"><a href="#修改-etc-pam-d-gdm-password" class="headerlink" title="修改/etc/pam.d/gdm-password"></a>修改/etc/pam.d/gdm-password</h2><p>注释掉auth required  pam_success_if.so user != root quiet_success</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/pam.d/gdm-password</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ql4ky9hmj314m0r6n78.jpg" alt></p><h2 id="修改-root-profile"><a href="#修改-root-profile" class="headerlink" title="修改/root/.profile"></a>修改/root/.profile</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /root/.profile</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ql5m5fpaj314q0r40vm.jpg" alt></p><h2 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>重启后<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ql9wwa5ij30rk0b4405.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qlab32dlj30nm08kab6.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qlanutr2j30oo09yq4e.jpg" alt></p><p>成功登录系统<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9qldxtpadj314u05ut9y.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文章说明&quot;&gt;&lt;a href=&quot;#文章说明&quot; class=&quot;headerlink&quot; title=&quot;文章说明&quot;&gt;&lt;/a&gt;文章说明&lt;/h2&gt;&lt;p&gt;本文主要介绍了在mac安装的Ubuntu虚拟机上，设置root密码，启用root账号。&lt;br&gt;默认情况下root账户并没有启
      
    
    </summary>
    
      <category term="Linux" scheme="https://iteverydaybro.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://iteverydaybro.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>FileOperation-One</title>
    <link href="https://iteverydaybro.github.io/2019/11/25/FileOperation-One/"/>
    <id>https://iteverydaybro.github.io/2019/11/25/FileOperation-One/</id>
    <published>2019-11-25T14:40:31.000Z</published>
    <updated>2019-11-27T01:29:24.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><p>最近一直在对文件/文件夹频繁进行操作，所以总结一下C#对文件以及文件夹尽心操作的记录以及心得体会。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bg2eugtaj315c0fggnz.jpg" alt></p><h2 id="对文件夹进行操作"><a href="#对文件夹进行操作" class="headerlink" title="对文件夹进行操作"></a>对文件夹进行操作</h2><p>对文件夹的操作主要有一下3个部分<br>1.DriveInfo<br>2.DirectoryInfo<br>3.Directory</p><h2 id="对文件进行操作"><a href="#对文件进行操作" class="headerlink" title="对文件进行操作"></a>对文件进行操作</h2><p>1.FileInfo<br>2.File<br>3.Path</p><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p>数据流（Stream）是对串行传输数据的一种抽象表示，是对输入/输出的一种抽象。数据有来源和目的地，衔接两者的就是串流对象。用比喻的方式来说，数据就好比水，串流对象就好比水管，通过水管的衔接，水由一端流向另一端。</p><h3 id="流的基本操作"><a href="#流的基本操作" class="headerlink" title="流的基本操作"></a>流的基本操作</h3><h3 id="流的种类"><a href="#流的种类" class="headerlink" title="流的种类"></a>流的种类</h3><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;p&gt;最近一直在对文件/文件夹频繁进行操作，所以总结一下C#对文件以及文件夹尽心操作的记录以及心得体会。&lt;br&gt;&lt;img src=
      
    
    </summary>
    
      <category term="File Operation" scheme="https://iteverydaybro.github.io/categories/File-Operation/"/>
    
    
      <category term="File Operation" scheme="https://iteverydaybro.github.io/tags/File-Operation/"/>
    
  </entry>
  
  <entry>
    <title>graphic-algorithm-seven</title>
    <link href="https://iteverydaybro.github.io/2019/11/01/graphic-algorithm-seven/"/>
    <id>https://iteverydaybro.github.io/2019/11/01/graphic-algorithm-seven/</id>
    <published>2019-10-31T16:00:12.000Z</published>
    <updated>2019-10-31T16:01:39.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><h1 id="狄克斯特拉算法"><a href="#狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法"></a>狄克斯特拉算法</h1><h2 id="加权图"><a href="#加权图" class="headerlink" title="加权图"></a>加权图</h2><p>提高或降低某些边的权重</p><h2 id="狄克斯特拉算法步骤"><a href="#狄克斯特拉算法步骤" class="headerlink" title="狄克斯特拉算法步骤"></a>狄克斯特拉算法步骤</h2><p>1.找出“最便宜”的节点，即可在最短时间内到达的节点<br>2.更新该节点的邻居的开销<br>3.重复这个过程，知道对图中的每个节点都这样做了<br>4.计算最短路径</p><h2 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h2><p>狄克斯特拉算法用于每条边都有关联的数字的图，这些数字称为权重<br>带权重的图称为加权图，不带权重的图称为非加权图<br>说明：要计算非加权图中的最短路径，可使用广度优先算法。要计算加权图中的最短路径，可使用狄克斯特拉算法。</p><h2 id="环"><a href="#环" class="headerlink" title="环"></a>环</h2><p>从A点出发，走一圈又回到A点</p><h2 id="狄克斯特拉算法只适用于有向无环图-狄克斯特拉算法"><a href="#狄克斯特拉算法只适用于有向无环图-狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法只适用于有向无环图 狄克斯特拉算法"></a>狄克斯特拉算法只适用于有向无环图 狄克斯特拉算法</h2><h2 id="如果有负权重边，就不能使用狄克斯特拉算法。可以使用贝尔曼-福德算法"><a href="#如果有负权重边，就不能使用狄克斯特拉算法。可以使用贝尔曼-福德算法" class="headerlink" title="如果有负权重边，就不能使用狄克斯特拉算法。可以使用贝尔曼-福德算法"></a>如果有负权重边，就不能使用狄克斯特拉算法。可以使用贝尔曼-福德算法</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;h1 id=&quot;狄克斯特拉算法&quot;&gt;&lt;a href=&quot;#狄克斯特拉算法&quot; class=&quot;headerlink&quot; title=&quot;狄克斯
      
    
    </summary>
    
      <category term="Graphic Algorithm" scheme="https://iteverydaybro.github.io/categories/Graphic-Algorithm/"/>
    
    
      <category term="Graphic Algorithm" scheme="https://iteverydaybro.github.io/tags/Graphic-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>graphic-algorithm-six</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/graphic-algorithm-six/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/graphic-algorithm-six/</id>
    <published>2019-10-31T15:57:25.000Z</published>
    <updated>2019-10-31T15:59:57.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><h1 id="广度优先算法"><a href="#广度优先算法" class="headerlink" title="广度优先算法"></a>广度优先算法</h1><h2 id="使用新的数据结构图来建立网路模型"><a href="#使用新的数据结构图来建立网路模型" class="headerlink" title="使用新的数据结构图来建立网路模型"></a>使用新的数据结构图来建立网路模型</h2><p>1.图：图模拟一组连接，图由节点和边组成。一个节点可能与众多节点直接连接，这些节点被称为邻居。<br>2.队列：FIFO（先进先出）的数据结构，<br>3.栈：LIFO（后进先出）的数据结构</p><h2 id="广度优先搜索–最短路径"><a href="#广度优先搜索–最短路径" class="headerlink" title="广度优先搜索–最短路径"></a>广度优先搜索–最短路径</h2><p>找出从起点到终点的最短路径长度<br>1.首先用代码实现图<br>每个节点都与邻近点相连–散列表<br>graph ={}<br>graph[“you”]=[“alice”,”bob”,”claire”]<br>你被映射到了一个数组，因此graph[“you”]是一个数组，其中包含了你的所有邻居<br>图不过是一系列的节点和边<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8htqb90x1j310u0q4woy.jpg" alt></p><h2 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h2><p>1.创建一个队列用户存储要检查的人<br>2.从队列中弹出一个人 出队<br>3.检查这个人是否是经销商<br>是：大功告成<br>否：将这个人的所有邻居加入队列 入队<br>4.回到第二步<br>5.如果队列为null，就说明你的人际关系网中没有芒果经销商</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">graph =&#123;&#125;</span><br><span class="line">graph[&quot;you&quot;]=[&quot;alice&quot;,&quot;bob&quot;,&quot;claire&quot;]</span><br><span class="line">graph[&quot;bob&quot;]=[&quot;anuj&quot;,&quot;peggy&quot;]</span><br><span class="line">graph[&quot;alice&quot;]=[&quot;peggy&quot;]</span><br><span class="line">graph[&quot;claire&quot;]=[&quot;thom&quot;,&quot;jonny&quot;]</span><br><span class="line">graph[&quot;anuj&quot;]=[]</span><br><span class="line">graph[&quot;peggy&quot;]=[]</span><br><span class="line">graph[&quot;thom&quot;]=[]</span><br><span class="line">graph[&quot;jonny&quot;]=[]</span><br><span class="line"></span><br><span class="line">from collections import deque</span><br><span class="line">def search(name):</span><br><span class="line">search_queue = deque()  //创建一个队列</span><br><span class="line">search_queue += graph[&quot;you&quot;] //加入你的邻居</span><br><span class="line">searched=[]</span><br><span class="line">while search_queue:</span><br><span class="line">person = search_queue.popleft()</span><br><span class="line">if person not in searched:</span><br><span class="line">if person_is_seller(person):</span><br><span class="line">print(person+&quot; is a mango serller!&quot;)</span><br><span class="line">else:</span><br><span class="line">search_queue+=graph[person]</span><br><span class="line">return False</span><br><span class="line"></span><br><span class="line">def person_is_seller(name):</span><br><span class="line">return name[-1]==&apos;m&apos;</span><br><span class="line">search(&quot;you&quot;)</span><br></pre></td></tr></table></figure><p>解决最短路径问题的算法被称为广度优先搜索<br>1.使用图来建立问题模型<br>2.使用广度优先搜索解决问题</p><h2 id="有向图与无向图"><a href="#有向图与无向图" class="headerlink" title="有向图与无向图"></a>有向图与无向图</h2><p>没有从他们出发指向其他人的箭头，这种被称为有向图，其中的关系是单向的。<br>无向图没有箭头，直接相连的节点互为邻居。</p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>指出了节点之间的依赖关系</p><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>图算法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;h1 id=&quot;广度优先算法&quot;&gt;&lt;a href=&quot;#广度优先算法&quot; class=&quot;headerlink&quot; title=&quot;广度优先算
      
    
    </summary>
    
      <category term="Graphic Algorithm" scheme="https://iteverydaybro.github.io/categories/Graphic-Algorithm/"/>
    
    
      <category term="Graphic Algorithm" scheme="https://iteverydaybro.github.io/tags/Graphic-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>graphic-algorithm-five</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/graphic-algorithm-five/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/graphic-algorithm-five/</id>
    <published>2019-10-31T15:55:28.000Z</published>
    <updated>2019-10-31T15:57:17.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><h2 id="什么是散列表"><a href="#什么是散列表" class="headerlink" title="什么是散列表"></a>什么是散列表</h2><p>散列表：最有用的基本数据结构之一</p><h2 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h2><p>散列表内部机制：实现 冲突和散列函数</p><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>无论你给它什么数据，它都还你一个数字 将输入映射到数字<br>散列函数总是将同样的输入映射到相同的索引<br>散列表（hash table）：结合数组和散列函数组成的数据结构<br>python提供的散列表实现为字典，用dict来创建散列表</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存的数据存在散列表中</p><h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>分配了相同的位置 链表</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>常量时间</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var voted=&#123;&#125;;</span><br><span class="line">def check_voter(name,):</span><br><span class="line">if voted.get(name)</span><br><span class="line">print(&quot;kick them out!&quot;)</span><br><span class="line">else:</span><br><span class="line">voted[name]=True;</span><br><span class="line">print(&quot;let them vote!&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;h1 id=&quot;散列表&quot;&gt;&lt;a href=&quot;#散列表&quot; class=&quot;headerlink&quot; title=&quot;散列表&quot;&gt;&lt;/a&gt;散列
      
    
    </summary>
    
      <category term="Graphic Algorithm" scheme="https://iteverydaybro.github.io/categories/Graphic-Algorithm/"/>
    
    
      <category term="Graphic Algorithm" scheme="https://iteverydaybro.github.io/tags/Graphic-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>graphic-algorithm-four</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/graphic-algorithm-four/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/graphic-algorithm-four/</id>
    <published>2019-10-31T15:53:14.000Z</published>
    <updated>2019-10-31T15:55:07.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h2><p>一种常见的优雅的排序算法。快速算法使用分而治之的策略</p><h2 id="分而治之（divide-and-conquer-D-amp-C）"><a href="#分而治之（divide-and-conquer-D-amp-C）" class="headerlink" title="分而治之（divide and conquer D&amp;C）"></a>分而治之（divide and conquer D&amp;C）</h2><p>一种著名的递归式问题解决方法<br>1.找出基线条件：这种条件必须尽可能简单<br>2.不断将问题分解（活着说缩小规模），直到符合基线条件。</p><h2 id="快速算法"><a href="#快速算法" class="headerlink" title="快速算法"></a>快速算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def quicksort(array):</span><br><span class="line">if len(array)&lt;2:</span><br><span class="line">return array</span><br><span class="line">else:</span><br><span class="line">pivot = array[0]</span><br><span class="line">less = [i for i in array[1:] if i&lt;=pivot]</span><br><span class="line">greeter = [i for i in array[1:] if i&gt;pivot]</span><br><span class="line">return quicksort(less)+pivot+quicksort(greeter)</span><br><span class="line">print quicksort([10,5,2,3])</span><br></pre></td></tr></table></figure><h2 id="最糟情况和平均情况"><a href="#最糟情况和平均情况" class="headerlink" title="最糟情况和平均情况"></a>最糟情况和平均情况</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8htmmosrcj30ho06b407.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Graphic Algorithm" scheme="https://iteverydaybro.github.io/categories/Graphic-Algorithm/"/>
    
    
      <category term="Graphic Algorithm" scheme="https://iteverydaybro.github.io/tags/Graphic-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>graphic-algorithm-three</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/graphic-algorithm-three/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/graphic-algorithm-three/</id>
    <published>2019-10-31T15:51:20.000Z</published>
    <updated>2019-10-31T15:52:59.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><h2 id="递归函数：自己调用自己的函数"><a href="#递归函数：自己调用自己的函数" class="headerlink" title="递归函数：自己调用自己的函数"></a>递归函数：自己调用自己的函数</h2><p>每个递归函数都有两部分<br>1.基线条件（base case）：函数不再调用自己<br>2.递归条件（recursive case）：函数调用自己</p><h2 id="栈-调用栈（call-stack）"><a href="#栈-调用栈（call-stack）" class="headerlink" title="栈 调用栈（call stack）"></a>栈 调用栈（call stack）</h2><p>栈有2种操作：压入和弹出<br>所有函数调用都进入调用栈<br>调用栈可能很长，这将占用大量内存。</p><h2 id="递归算法：寻找钥匙伪代码"><a href="#递归算法：寻找钥匙伪代码" class="headerlink" title="递归算法：寻找钥匙伪代码"></a>递归算法：寻找钥匙伪代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def look_for_key(box):</span><br><span class="line">for item in box:</span><br><span class="line">if item.is_a_box():</span><br><span class="line">look_for_key(item)</span><br><span class="line"> elif:item.is_a_key():</span><br><span class="line">print &quot;Found the key!&quot;</span><br></pre></td></tr></table></figure><h2 id="倒计时递归"><a href="#倒计时递归" class="headerlink" title="倒计时递归"></a>倒计时递归</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def countdown(i):</span><br><span class="line">print i</span><br><span class="line">if i&lt;=1:</span><br><span class="line">return</span><br><span class="line">else:</span><br><span class="line">countdown(i)</span><br><span class="line"></span><br><span class="line">print countdown(10)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;h1 id=&quot;递归算法&quot;&gt;&lt;a href=&quot;#递归算法&quot; class=&quot;headerlink&quot; title=&quot;递归算法&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Graphic Algorithm" scheme="https://iteverydaybro.github.io/categories/Graphic-Algorithm/"/>
    
    
      <category term="Graphic Algorithm" scheme="https://iteverydaybro.github.io/tags/Graphic-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>graphic-algorithm-two</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/graphic-algorithm-two/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/graphic-algorithm-two/</id>
    <published>2019-10-31T15:48:48.000Z</published>
    <updated>2019-10-31T15:51:09.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表中的元素可存储在内存的任何地方<br>链表中的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>需要随机的读取元素时，数组的效率很高。支持随机访问和顺序访问。</p><h2 id="数组与链表操作的运行时间"><a href="#数组与链表操作的运行时间" class="headerlink" title="数组与链表操作的运行时间"></a>数组与链表操作的运行时间</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hthofcvzj30hg09u76w.jpg" alt></p><h2 id="选择排序算法"><a href="#选择排序算法" class="headerlink" title="选择排序算法"></a>选择排序算法</h2><h3 id="先编写查找最小元素的函数"><a href="#先编写查找最小元素的函数" class="headerlink" title="先编写查找最小元素的函数"></a>先编写查找最小元素的函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    def findSmallest(arr):</span><br><span class="line">smallest =arr[0]</span><br><span class="line">smallest_index = 0</span><br><span class="line">for i in range(1,len(arr)):</span><br><span class="line">if arr[i]&lt;smallest:</span><br><span class="line">smallest=arr[i]</span><br><span class="line">smallest_index =i</span><br><span class="line">return smallest_index</span><br></pre></td></tr></table></figure><h3 id="编写排序算法"><a href="#编写排序算法" class="headerlink" title="编写排序算法"></a>编写排序算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def selectionSort(arr):</span><br><span class="line">newArr = []</span><br><span class="line">for i in range(len(arr)):</span><br><span class="line">smallest = findSmallest(arr)</span><br><span class="line">newArr.append(arr.pop(smallest))</span><br><span class="line">return newArr</span><br><span class="line">print selectionSort([5,3,6,2,10])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;h1 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Graphic Algorithm" scheme="https://iteverydaybro.github.io/categories/Graphic-Algorithm/"/>
    
    
      <category term="Graphic Algorithm" scheme="https://iteverydaybro.github.io/tags/Graphic-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>graphic-algorithm-one</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/graphic-algorithm-one/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/graphic-algorithm-one/</id>
    <published>2019-10-31T15:46:18.000Z</published>
    <updated>2019-10-31T15:48:42.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><h2 id="编写第一种查找算法–二分查找"><a href="#编写第一种查找算法–二分查找" class="headerlink" title="编写第一种查找算法–二分查找"></a>编写第一种查找算法–二分查找</h2><p>二分查找前提条件：要查找的列表为有序列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def binary_search(list,item):</span><br><span class="line">low =0</span><br><span class="line">high = len(list)-1</span><br><span class="line"></span><br><span class="line">while low&lt;=high:</span><br><span class="line">mid = (low+high)/2     </span><br><span class="line">guess = list[mid]</span><br><span class="line">if guess == item:</span><br><span class="line">return mid</span><br><span class="line">if guess &gt; item:</span><br><span class="line">high = mid -1</span><br><span class="line">else:</span><br><span class="line">low = mid +1</span><br><span class="line">return None</span><br><span class="line">my_list = [1,3,5,7,9]</span><br><span class="line">print binary_search(my_list,3)</span><br><span class="line">print binary_search(my_list,-1)</span><br></pre></td></tr></table></figure><h2 id="算法时间复杂度分析"><a href="#算法时间复杂度分析" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h2><p>二分查找算法运行时间：O(logn)</p><h2 id="算法的运行时间：大O表示法"><a href="#算法的运行时间：大O表示法" class="headerlink" title="算法的运行时间：大O表示法"></a>算法的运行时间：大O表示法</h2><p>大O表示法让你能够比较操作数，它指出了算法运行时间的增速<br>算法的运行时间是从其增速的角度度量的。</p><h2 id="了解常用的算法设计方法–递归"><a href="#了解常用的算法设计方法–递归" class="headerlink" title="了解常用的算法设计方法–递归"></a>了解常用的算法设计方法–递归</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;h1 id=&quot;算法简介&quot;&gt;&lt;a href=&quot;#算法简介&quot; class=&quot;headerlink&quot; title=&quot;算法简介&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Graphic Algorithm" scheme="https://iteverydaybro.github.io/categories/Graphic-Algorithm/"/>
    
    
      <category term="Graphic Algorithm" scheme="https://iteverydaybro.github.io/tags/Graphic-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>sql-one</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/sql-one/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/sql-one/</id>
    <published>2019-10-31T15:42:14.000Z</published>
    <updated>2019-10-31T15:45:29.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><h1 id="常用的SQL总结"><a href="#常用的SQL总结" class="headerlink" title="常用的SQL总结"></a>常用的SQL总结</h1><h2 id="链接服务器"><a href="#链接服务器" class="headerlink" title="链接服务器"></a>链接服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_addlinkedserver @server = ’MySQLTest’, @srvproduct=’MySQL’,  </span><br><span class="line">　　@provider = ’MSDASQL’, @datasrc = ’myDSN’  </span><br><span class="line">　　GO  </span><br><span class="line">　　EXEC sp_addlinkedsrvlogin  </span><br><span class="line">　　@rmtsrvname=’MySqlTest’,@useself=’false’,@locallogin=’sa’,@rmtuser=’mysql的用户名’,@rmtpassword=’mysql的密码’</span><br><span class="line"></span><br><span class="line">exec sp_addlinkedserver @server=&apos;MtOld&apos;,@provider=&apos;sqloledb&apos;,@srvproduct=&apos;&apos;,@datasrc=&apos;47.88.24.214&apos;</span><br><span class="line"></span><br><span class="line">EXEC sp_addlinkedsrvlogin @rmtsrvname = &apos;MtOld&apos;, @useself = &apos;false&apos;, @locallogin = &apos;sa&apos;, @rmtuser = &apos;LabNet&apos;, @rmtpassword = &apos;2p3XEI21hEy935Y2&apos;</span><br></pre></td></tr></table></figure><h2 id="表连接使用方法"><a href="#表连接使用方法" class="headerlink" title="表连接使用方法"></a>表连接使用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM  A INNER JOIN   B ON A.Name COLLATE Chinese_PRC_CI_AS =B.Name</span><br></pre></td></tr></table></figure><h2 id="创建视图解决问题"><a href="#创建视图解决问题" class="headerlink" title="创建视图解决问题"></a>创建视图解决问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT Name COLLATE Chinese_PRC_CI_AS FROM A</span><br></pre></td></tr></table></figure><h2 id="SQL-Latin1-General-CP1-CI-AS冲突"><a href="#SQL-Latin1-General-CP1-CI-AS冲突" class="headerlink" title="SQL_Latin1_General_CP1_CI_AS冲突"></a>SQL_Latin1_General_CP1_CI_AS冲突</h2><p>出现无法解决 equal to 操作中 “SQL_Latin1_General_CP1_CI_AS” 和 “Chinese_PRC_CI_AS” 之间的排序规则冲突 问题<br>可以用显示转换的方法解决<br>COLLATE SQL_collation_name   SQL_collation_name 为SQL SERVE 排序规则名称</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;h1 id=&quot;常用的SQL总结&quot;&gt;&lt;a href=&quot;#常用的SQL总结&quot; class=&quot;headerlink&quot; title=&quot;常
      
    
    </summary>
    
      <category term="SQL" scheme="https://iteverydaybro.github.io/categories/SQL/"/>
    
    
      <category term="SQL" scheme="https://iteverydaybro.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>redis-three</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/redis-three/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/redis-three/</id>
    <published>2019-10-31T15:40:56.000Z</published>
    <updated>2019-10-31T15:41:24.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><h1 id="Redis部署"><a href="#Redis部署" class="headerlink" title="Redis部署"></a>Redis部署</h1><p>1.redis-cli.exe -h 127.0.0.1 -p 6379<br>2.redis-cli.exe -h 127.0.0.1 -p 6380<br>3.redis-server.exe redis.windows.6381.conf<br>4.redis-cli.exe -h 127.0.0.1 -p 6380<br>5.redis-server.exe redis.sentinal.conf<br>6.redis-server.exe redis.sentinal.26479.conf<br>7.redis-server.exe redis.sentinal.26579.conf<br>8.redis-cli.exe -h 127.0.0.1 -p 26379</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;h1 id=&quot;Redis部署&quot;&gt;&lt;a href=&quot;#Redis部署&quot; class=&quot;headerlink&quot; title=&quot;Red
      
    
    </summary>
    
      <category term="Redis" scheme="https://iteverydaybro.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://iteverydaybro.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>redis-two</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/redis-two/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/redis-two/</id>
    <published>2019-10-31T15:23:55.000Z</published>
    <updated>2019-11-01T00:39:46.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><h1 id="redis配置详解"><a href="#redis配置详解" class="headerlink" title="redis配置详解"></a>redis配置详解</h1><p>Redis configuration file example.<br>Note that in order to read the configuration file, Redis must be<br>started with the file path as first argument:</p><p> ./redis-server /path/to/redis.conf</p><p>Note on units: when memory size is needed, it is possible to specify<br>it in the usual form of 1k 5GB 4M and so forth:</p><p> 1k =&gt; 1000 bytes<br> 1kb =&gt; 1024 bytes<br> 1m =&gt; 1000000 bytes<br> 1mb =&gt; 1024<em>1024 bytes<br> 1g =&gt; 1000000000 bytes<br> 1gb =&gt; 1024</em>1024*1024 bytes</p><p> units are case insensitive so 1GB 1Gb 1gB are all the same.</p><p>################################## INCLUDES ###################################</p><p>################################## 包含     ###################################</p><p> Include one or more other config files here.  This is useful if you<br> have a standard template that goes to all Redis servers but also need<br> to customize a few per-server settings.  Include files can include<br> other files, so use this wisely.</p><p> Notice option “include” won’t be rewritten by command “CONFIG REWRITE”<br> from admin or Redis Sentinel. Since Redis always uses the last processed<br> line as value of a configuration directive, you’d better put includes<br> at the beginning of this file to avoid overwriting config change at runtime.</p><p> If instead you are interested in using includes to override configuration<br> options, it is better to use include as the last line.</p><p> 假如说你有一个可用于所有的 redis server 的标准配置模板，<br> 但针对某些 server 又需要一些个性化的设置，<br> 你可以使用 include 来包含一些其他的配置文件，这对你来说是非常有用的。</p><p> 但是要注意哦，include 是不能被 config rewrite 命令改写的<br> 由于 redis 总是以最后的加工线作为一个配置指令值，所以你最好是把 include 放在这个文件的最前面，<br> 以避免在运行时覆盖配置的改变，相反，你就把它放在后面<br> include /path/to/local.conf<br> include /path/to/other.conf</p><p>################################ GENERAL  #####################################</p><p>################################ 常用     #####################################</p><p> By default Redis does not run as a daemon. Use ‘yes’ if you need it.<br> Note that Redis will write a pid file in /var/run/redis.pid when daemonized.<br> 默认情况下 redis 不是作为守护进程运行的，如果你想让它在后台运行，你就把它改成 yes。<br> 当redis作为守护进程运行的时候，它会写一个 pid 到 /var/run/redis.pid 文件里面。<br>daemonize yes</p><p> When running daemonized, Redis writes a pid file in /var/run/redis.pid by<br> default. You can specify a custom pid file location here.<br> 当 Redis 以守护进程的方式运行的时候，Redis 默认会把 pid 文件放在/var/run/redis.pid<br> 可配置到其他地址，当运行多个 redis 服务时，需要指定不同的 pid 文件和端口<br> 指定存储Redis进程号的文件路径<br>pidfile /var/run/redis.pid</p><p> Accept connections on the specified port, default is 6379.<br> If port 0 is specified Redis will not listen on a TCP socket.<br> 端口，默认端口是6379，生产环境中建议更改端口号，安全性更高<br> 如果你设为 0 ，redis 将不在 socket 上监听任何客户端连接。<br> port 9966</p><p> TCP listen() backlog.</p><p> In high requests-per-second environments you need an high backlog in order<br> to avoid slow clients connections issues. Note that the Linux kernel<br> will silently truncate it to the value of /proc/sys/net/core/somaxconn so<br> make sure to raise both the value of somaxconn and tcp_max_syn_backlog<br> in order to get the desired effect.<br> TCP 监听的最大容纳数量<br> 此参数确定了TCP连接中已完成队列(完成三次握手之后)的长度，<br> 当系统并发量大并且客户端速度缓慢的时候，你需要把这个值调高以避免客户端连接缓慢的问题。<br> Linux 内核会一声不响的把这个值缩小成 /proc/sys/net/core/somaxconn 对应的值，默认是511，而Linux的默认参数值是128。<br> 所以可以将这二个参数一起参考设定，你以便达到你的预期。</p><p> tcp-backlog 511</p><p> By default Redis listens for connections from all the network interfaces<br> available on the server. It is possible to listen to just one or multiple<br> interfaces using the “bind” configuration directive, followed by one or<br> more IP addresses.</p><p> Examples:</p><p> bind 192.168.1.100 10.0.0.1<br> 有时候为了安全起见，redis一般都是监听127.0.0.1 但是有时候又有同网段能连接的需求，当然可以绑定0.0.0.0 用iptables来控制访问权限，或者设置redis访问密码来保证数据安全</p><p> 不设置将处理所有请求,建议生产环境中设置，有个误区：bind是用来限制外网IP访问的，其实不是，限制外网ip访问可以通过iptables；如：-A INPUT -s 10.10.1.0/24 -p tcp -m state –state NEW -m tcp –dport 9966 -j ACCEPT ；<br> 实际上，bind ip 绑定的是redis所在服务器网卡的ip，当然127.0.0.1也是可以的<br> 如果绑定一个外网ip，就会报错：Creating Server TCP listening socket xxx.xxx.xxx.xxx:9966: bind: Cannot assign requested address</p><p> bind 127.0.0.1<br> bind 127.0.0.1 10.10.1.3</p><p> 假设绑定是以上ip，使用 netstat -anp|grep 9966 会发现，这两个ip被bind，其中10.10.1.3是服务器网卡的ip<br> tcp        0      0 10.10.1.3:9966         0.0.0.0:*                   LISTEN      11188/redis-server<br> tcp        0      0 127.0.0.1:9966         0.0.0.0:*                   LISTEN      11188/redis-server </p><p> Specify the path for the Unix socket that will be used to listen for<br> incoming connections. There is no default, so Redis will not listen<br> on a unix socket when not specified.</p><p> unixsocket /tmp/redis.sock<br> unixsocketperm 700</p><p> Close the connection after a client is idle for N seconds (0 to disable)<br> 客户端和Redis服务端的连接超时时间，默认是0，表示永不超时。<br> timeout 0</p><p> TCP keepalive.</p><p> If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence<br> of communication. This is useful for two reasons:</p><p> 1) Detect dead peers.<br> 2) Take the connection alive from the point of view of network<br>    equipment in the middle.</p><p> On Linux, the specified value (in seconds) is the period used to send ACKs.<br> Note that to close the connection the double of the time is needed.<br> On other kernels the period depends on the kernel configuration.</p><p> A reasonable value for this option is 60 seconds.</p><p> tcp 心跳包。</p><p> 如果设置为非零，则在与客户端缺乏通讯的时候使用 SO_KEEPALIVE 发送 tcp acks 给客户端。<br> 这个之所有有用，主要由两个原因：</p><p> 1) 防止死的 peers<br> 2) Take the connection alive from the point of view of network<br>    equipment in the middle.</p><p> 推荐一个合理的值就是60秒<br> tcp-keepalive 0</p><p> Specify the server verbosity level.<br> This can be one of:<br> debug (a lot of information, useful for development/testing)<br> verbose (many rarely useful info, but not a mess like the debug level)<br> notice (moderately verbose, what you want in production probably)<br> warning (only very important / critical messages are logged)<br> 日志记录等级，4个可选值debug,verbose,notice,warning<br> 可以是下面的这些值：<br> debug (适用于开发或测试阶段)<br> verbose (many rarely useful info, but not a mess like the debug level)<br> notice (适用于生产环境)<br> warning (仅仅一些重要的消息被记录)<br> loglevel notice</p><p> Specify the log file name. Also the empty string can be used to force<br> Redis to log on the standard output. Note that if you use standard<br> output for logging but daemonize, logs will be sent to /dev/null<br> 配置 log 文件地址,默认打印在命令行终端的窗口上，也可设为/dev/null屏蔽日志、<br> logfile “/data/logs/redis/redis.log”</p><p> To enable logging to the system logger, just set ‘syslog-enabled’ to yes,<br> and optionally update the other syslog parameters to suit your needs.<br> 要想把日志记录到系统日志，就把它改成 yes，<br>也可以可选择性的更新其他的syslog 参数以达到你的要求<br>syslog-enabled no</p><p>Specify the syslog identity.<br>设置 syslog 的 identity。<br>syslog-ident redis</p><p>Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.<br>syslog-facility local0</p><p>Set the number of databases. The default database is DB 0, you can select<br>a different one on a per-connection basis using SELECT <dbid> where<br>dbid is a number between 0 and ‘databases’-1<br>可用的数据库数，默认值为16，默认数据库为0，数据库范围在0-（database-1）之间<br>databases 16</dbid></p><p>################################ SNAPSHOTTING  ################################</p><p>################################ 快照          ################################</p><p>Save the DB on disk:</p><p>  save <seconds> <changes></changes></seconds></p><p>  Will save the DB if both the given number of seconds and the given<br>  number of write operations against the DB occurred.</p><p>  In the example below the behaviour will be to save:<br>  after 900 sec (15 min) if at least 1 key changed<br>  after 300 sec (5 min) if at least 10 keys changed<br>  after 60 sec if at least 10000 keys changed</p><p>  Note: you can disable saving completely by commenting out all “save” lines.</p><p>  It is also possible to remove all the previously configured save<br>  points by adding a save directive with a single empty string argument<br>  like in the following example:</p><p>  save “”<br>在 900 秒内最少有 1 个 key 被改动，或者 300 秒内最少有 10 个 key 被改动，又或者 60 秒内最少有 1000 个 key 被改动，以上三个条件随便满足一个，就触发一次保存操作。</p><p>   if(在60秒之内有10000个keys发生变化时){<br>     进行镜像备份<br>   }else if(在300秒之内有10个keys发生了变化){<br>     进行镜像备份<br>   }else if(在900秒之内有1个keys发生了变化){<br>     进行镜像备份<br>   }</p><p>save 900 1<br>save 300 10<br>save 60 10000</p><p>By default Redis will stop accepting writes if RDB snapshots are enabled<br>(at least one save point) and the latest background save failed.<br>This will make the user aware (in a hard way) that data is not persisting<br>on disk properly, otherwise chances are that no one will notice and some<br>:/ disaster will happen.</p><p>If the background saving process will start working again Redis will<br>automatically allow writes again.</p><p>However if you have setup your proper monitoring of the Redis server<br>and persistence, you may want to disable this feature so that Redis will<br>continue to work as usual even if there are problems with disk,<br>permissions, and so forth.<br>默认情况下，如果 redis 最后一次的后台保存失败，redis 将停止接受写操作，<br>这样以一种强硬的方式让用户知道数据不能正确的持久化到磁盘，<br>否则就会没人注意到灾难的发生。</p><p>如果后台保存进程重新启动工作了，redis 也将自动的允许写操作。</p><p>然而你要是安装了靠谱的监控，你可能不希望 redis 这样做，那你就改成 no 好<br>stop-writes-on-bgsave-error yes</p><p>Compress string objects using LZF when dump .rdb databases?<br>For default that’s set to ‘yes’ as it’s almost always a win.<br>If you want to save some CPU in the saving child set it to ‘no’ but<br>the dataset will likely be bigger if you have compressible values or keys.<br>在进行备份时,是否进行压缩<br>是否在 dump .rdb 数据库的时候使用 LZF 压缩字符串<br>默认都设为 yes<br>如果你希望保存子进程节省点 cpu ，你就设置它为 no ，<br>不过这个数据集可能就会比较大<br>rdbcompression yes</p><p>Since version 5 of RDB a CRC64 checksum is placed at the end of the file.<br>This makes the format more resistant to corruption but there is a performance<br>hit to pay (around 10%) when saving and loading RDB files, so you can disable it<br>for maximum performances.</p><p>RDB files created with checksum disabled have a checksum of zero that will<br>tell the loading code to skip the check.<br>读取和写入的时候是否支持CRC64校验，默认是开启的<br>rdbchecksum yes</p><p>The filename where to dump the DB<br>备份文件的文件名<br>dbfilename dump.rdb</p><p>The working directory.</p><p>The DB will be written inside this directory, with the filename specified<br>above using the ‘dbfilename’ configuration directive.</p><p>The Append Only File will also be created inside this directory.</p><p>Note that you must specify a directory here, not a file name.<br>数据库备份的文件放置的路径<br>路径跟文件名分开配置是因为 Redis 备份时，先会将当前数据库的状态写入到一个临时文件<br>等备份完成时，再把该临时文件替换为上面所指定的文件<br>而临时文件和上面所配置的备份文件都会放在这个指定的路径当中<br>默认值为 ./<br>dir /data/data/redis/</p><p>################################# REPLICATION #################################</p><p>################################# 主从复制    #################################<br>Master-Slave replication. Use slaveof to make a Redis instance a copy of<br>another Redis server. A few things to understand ASAP about Redis replication.</p><p>1) Redis replication is asynchronous, but you can configure a master to<br>   stop accepting writes if it appears to be not connected with at least<br>   a given number of slaves.<br>2) Redis slaves are able to perform a partial resynchronization with the<br>   master if the replication link is lost for a relatively small amount of<br>   time. You may want to configure the replication backlog size (see the next<br>   sections of this file) with a sensible value depending on your needs.<br>3) Replication is automatic and does not need user intervention. After a<br>   network partition slaves automatically try to reconnect to masters<br>   and resynchronize with them.</p><p>设置该数据库为其他数据库的从数据库<br>slaveof <masterip> <masterport> 当本机为从服务时，设置主服务的IP及端口<br>slaveof <masterip> <masterport></masterport></masterip></masterport></masterip></p><p>If the master is password protected (using the “requirepass” configuration<br>directive below) it is possible to tell the slave to authenticate before<br>starting the replication synchronization process, otherwise the master will<br>refuse the slave request.</p><p>指定与主数据库连接时需要的密码验证<br>masterauth <master-password> 当本机为从服务时，设置访问master服务器的密码<br>masterauth <master-password></master-password></master-password></p><p>When a slave loses its connection with the master, or when the replication<br>is still in progress, the slave can act in two different ways:</p><p>1) if slave-serve-stale-data is set to ‘yes’ (the default) the slave will<br>   still reply to client requests, possibly with out of date data, or the<br>   data set may just be empty if this is the first synchronization.</p><p>2) if slave-serve-stale-data is set to ‘no’ the slave will reply with<br>   an error “SYNC with master in progress” to all the kind of commands<br>   but to INFO and SLAVEOF.</p><p>当slave服务器和master服务器失去连接后，或者当数据正在复制传输的时候，如果此参数值设置“yes”，slave服务器可以继续接受客户端的请求，否则，会返回给请求的客户端如下信息“SYNC with master in progress”,除了INFO，SLAVEOF这两个命令<br>slave-serve-stale-data yes</p><p>You can configure a slave instance to accept writes or not. Writing against<br>a slave instance may be useful to store some ephemeral data (because data<br>written on a slave will be easily deleted after resync with the master) but<br>may also cause problems if clients are writing to it because of a<br>misconfiguration.</p><p>Since Redis 2.6 by default slaves are read-only.</p><p>Note: read only slaves are not designed to be exposed to untrusted clients<br>on the internet. It’s just a protection layer against misuse of the instance.<br>Still a read only slave exports by default all the administrative commands<br>such as CONFIG, DEBUG, and so forth. To a limited extent you can improve<br>security of read only slaves using ‘rename-command’ to shadow all the<br>administrative / dangerous commands.<br>是否允许slave服务器节点只提供读服务<br>slave-read-only yes</p><p>Replication SYNC strategy: disk or socket.</p><hr><h2 id="WARNING-DISKLESS-REPLICATION-IS-EXPERIMENTAL-CURRENTLY"><a href="#WARNING-DISKLESS-REPLICATION-IS-EXPERIMENTAL-CURRENTLY" class="headerlink" title="WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY"></a>WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY</h2><p>New slaves and reconnecting slaves that are not able to continue the replication<br>process just receiving differences, need to do what is called a “full<br>synchronization”. An RDB file is transmitted from the master to the slaves.<br>The transmission can happen in two different ways:</p><p>1) Disk-backed: The Redis master creates a new process that writes the RDB<br>                file on disk. Later the file is transferred by the parent<br>                process to the slaves incrementally.<br>2) Diskless: The Redis master creates a new process that directly writes the<br>             RDB file to slave sockets, without touching the disk at all.</p><p>With disk-backed replication, while the RDB file is generated, more slaves<br>can be queued and served with the RDB file as soon as the current child producing<br>the RDB file finishes its work. With diskless replication instead once<br>the transfer starts, new slaves arriving will be queued and a new transfer<br>will start when the current one terminates.</p><p>When diskless replication is used, the master waits a configurable amount of<br>time (in seconds) before starting the transfer in the hope that multiple slaves<br>will arrive and the transfer can be parallelized.</p><p>With slow disks and fast (large bandwidth) networks, diskless replication<br>works better.<br>repl-diskless-sync no</p><p>When diskless replication is enabled, it is possible to configure the delay<br>the server waits in order to spawn the child that transfers the RDB via socket<br>to the slaves.</p><p>This is important since once the transfer starts, it is not possible to serve<br>new slaves arriving, that will be queued for the next RDB transfer, so the server<br>waits a delay in order to let more slaves arrive.</p><p>The delay is specified in seconds, and by default is 5 seconds. To disable<br>it entirely just set it to 0 seconds and the transfer will start ASAP.<br>repl-diskless-sync-delay 5</p><p>Slaves send PINGs to server in a predefined interval. It’s possible to change<br>this interval with the repl_ping_slave_period option. The default value is 10<br>seconds.</p><p>Slaves 在一个预定义的时间间隔内发送 ping 命令到 server 。<br>你可以改变这个时间间隔。默认为 10 秒。<br>repl-ping-slave-period 10</p><p>The following option sets the replication timeout for:</p><p>1) Bulk transfer I/O during SYNC, from the point of view of slave.<br>2) Master timeout from the point of view of slaves (data, pings).<br>3) Slave timeout from the point of view of masters (REPLCONF ACK pings).</p><p>It is important to make sure that this value is greater than the value<br>specified for repl-ping-slave-period otherwise a timeout will be detected<br>every time there is low traffic between the master and the slave.</p><p>设置主从复制过期时间<br>这个值一定要比 repl-ping-slave-period 大<br>repl-timeout 60</p><p>Disable TCP_NODELAY on the slave socket after SYNC?</p><p>If you select “yes” Redis will use a smaller number of TCP packets and<br>less bandwidth to send data to slaves. But this can add a delay for<br>the data to appear on the slave side, up to 40 milliseconds with<br>Linux kernels using a default configuration.</p><p>If you select “no” the delay for data to appear on the slave side will<br>be reduced but more bandwidth will be used for replication.</p><p>By default we optimize for low latency, but in very high traffic conditions<br>or when the master and slaves are many hops away, turning this to “yes” may<br>be a good idea.<br>指定向slave同步数据时，是否禁用socket的NO_DELAY选 项。若配置为“yes”，则禁用NO_DELAY，则TCP协议栈会合并小包统一发送，这样可以减少主从节点间的包数量并节省带宽，但会增加数据同步到 slave的时间。若配置为“no”，表明启用NO_DELAY，则TCP协议栈不会延迟小包的发送时机，这样数据同步的延时会减少，但需要更大的带宽。 通常情况下，应该配置为no以降低同步延时，但在主从节点间网络负载已经很高的情况下，可以配置为yes。<br>repl-disable-tcp-nodelay no</p><p>Set the replication backlog size. The backlog is a buffer that accumulates<br>slave data when slaves are disconnected for some time, so that when a slave<br>wants to reconnect again, often a full resync is not needed, but a partial<br>resync is enough, just passing the portion of data the slave missed while<br>disconnected.</p><p>The bigger the replication backlog, the longer the time the slave can be<br>disconnected and later be able to perform a partial resynchronization.</p><p>The backlog is only allocated once there is at least a slave connected.</p><p>设置主从复制容量大小。这个 backlog 是一个用来在 slaves 被断开连接时<br>存放 slave 数据的 buffer，所以当一个 slave 想要重新连接，通常不希望全部重新同步，<br>只是部分同步就够了，仅仅传递 slave 在断开连接时丢失的这部分数据。</p><p>The biggest the replication backlog, the longer the time the slave can be<br>disconnected and later be able to perform a partial resynchronization.<br>这个值越大，salve 可以断开连接的时间就越长。</p><p>repl-backlog-size 1mb</p><p>After a master has no longer connected slaves for some time, the backlog<br>will be freed. The following option configures the amount of seconds that<br>need to elapse, starting from the time the last slave disconnected, for<br>the backlog buffer to be freed.</p><p>A value of 0 means to never release the backlog.</p><p>在某些时候，master 不再连接 slaves，backlog 将被释放。<br>如果设置为 0 ，意味着绝不释放 backlog 。<br>repl-backlog-ttl 3600</p><p>The slave priority is an integer number published by Redis in the INFO output.<br>It is used by Redis Sentinel in order to select a slave to promote into a<br>master if the master is no longer working correctly.</p><p>A slave with a low priority number is considered better for promotion, so<br>for instance if there are three slaves with priority 10, 100, 25 Sentinel will<br>pick the one with priority 10, that is the lowest.</p><p>However a special priority of 0 marks the slave as not able to perform the<br>role of master, so a slave with priority of 0 will never be selected by<br>Redis Sentinel for promotion.</p><p>By default the priority is 100.<br>指定slave的优先级。在不只1个slave存在的部署环境下，当master宕机时，Redis<br>Sentinel会将priority值最小的slave提升为master。<br>这个值越小，就越会被优先选中，需要注意的是，<br>若该配置项为0，则对应的slave永远不会自动提升为master。<br>slave-priority 100</p><p>It is possible for a master to stop accepting writes if there are less than<br>N slaves connected, having a lag less or equal than M seconds.</p><p>The N slaves need to be in “online” state.</p><p>The lag in seconds, that must be &lt;= the specified value, is calculated from<br>the last ping received from the slave, that is usually sent every second.</p><p>This option does not GUARANTEE that N replicas will accept the write, but<br>will limit the window of exposure for lost writes in case not enough slaves<br>are available, to the specified number of seconds</p><p>For example to require at least 3 slaves with a lag &lt;= 10 seconds use:</p><p>min-slaves-to-write 3<br>min-slaves-max-lag 10</p><p>Setting one or the other to 0 disables the feature.</p><p>By default min-slaves-to-write is set to 0 (feature disabled) and<br>min-slaves-max-lag is set to 10.</p><p>################################## SECURITY ###################################</p><p>################################## 安全     ###################################</p><p>Require clients to issue AUTH <password> before processing any other<br>commands.  This might be useful in environments in which you do not trust<br>others with access to the host running redis-server.</password></p><p>This should stay commented out for backward compatibility and because most<br>people do not need auth (e.g. they run their own servers).</p><p>Warning: since Redis is pretty fast an outside user can try up to<br>150k passwords per second against a good box. This means that you should<br>use a very strong password otherwise it will be very easy to break.</p><p>设置连接redis的密码<br>redis速度相当快，一个外部用户在一秒钟进行150K次密码尝试，需指定强大的密码来防止暴力破解<br>requirepass set_enough_strong_passwd</p><p>Command renaming.</p><p>It is possible to change the name of dangerous commands in a shared<br>environment. For instance the CONFIG command may be renamed into something<br>hard to guess so that it will still be available for internal-use tools<br>but not available for general clients.</p><p>Example:</p><p>rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</p><p>It is also possible to completely kill a command by renaming it into<br>an empty string:</p><p>rename-command CONFIG “”</p><p>Please note that changing the name of commands that are logged into the<br>AOF file or transmitted to slaves may cause problems.<br>重命名一些高危命令，用来禁止高危命令<br>rename-command FLUSHALL ZYzv6FOBdwflW2nX<br>rename-command CONFIG aI7zwm1GDzMMrEi<br>rename-command EVAL S9UHPKEpSvUJMM<br>rename-command FLUSHDB D60FPVDJuip7gy6l</p><p>################################### LIMITS ####################################</p><p>################################### 限制   ####################################</p><p>Set the max number of connected clients at the same time. By default<br>this limit is set to 10000 clients, however if the Redis server is not<br>able to configure the process file limit to allow for the specified limit<br>the max number of allowed clients is set to the current file limit<br>minus 32 (as Redis reserves a few file descriptors for internal uses).</p><p>Once the limit is reached Redis will close all the new connections sending<br>an error ‘max number of clients reached’.</p><p>限制同时连接的客户数量,默认是10000<br>当连接数超过这个值时，redis 将不再接收其他连接请求，客户端尝试连接时将收到 error 信息<br>maxclients 10000</p><p>Don’t use more memory than the specified amount of bytes.<br>When the memory limit is reached Redis will try to remove keys<br>according to the eviction policy selected (see maxmemory-policy).</p><p>If Redis can’t remove keys according to the policy, or if the policy is<br>set to ‘noeviction’, Redis will start to reply with errors to commands<br>that would use more memory, like SET, LPUSH, and so on, and will continue<br>to reply to read-only commands like GET.</p><p>This option is usually useful when using Redis as an LRU cache, or to set<br>a hard memory limit for an instance (using the ‘noeviction’ policy).</p><p>WARNING: If you have slaves attached to an instance with maxmemory on,<br>the size of the output buffers needed to feed the slaves are subtracted<br>from the used memory count, so that network problems / resyncs will<br>not trigger a loop where keys are evicted, and in turn the output<br>buffer of slaves is full with DELs of keys evicted triggering the deletion<br>of more keys, and so forth until the database is completely emptied.</p><p>In short… if you have slaves attached it is suggested that you set a lower<br>limit for maxmemory so that there is some free RAM on the system for slave<br>output buffers (but this is not needed if the policy is ‘noeviction’).</p><p>设置redis能够使用的最大内存。<br>达到最大内存设置后，Redis会先尝试清除已到期或即将到期的Key（设置过expire信息的key）<br>在删除时,按照过期时间进行删除，最早将要被过期的key将最先被删除<br>如果已到期或即将到期的key删光，仍进行set操作，那么将返回错误<br>此时redis将不再接收写请求,只接收get请求。<br>maxmemory的设置比较适合于把redis当作于类似memcached 的缓存来使用<br>maxmemory <bytes></bytes></p><p>MAXMEMORY POLICY: how Redis will select what to remove when maxmemory<br>is reached. You can select among five behaviors:</p><p>volatile-lru -&gt; remove the key with an expire set using an LRU algorithm<br>allkeys-lru -&gt; remove any key according to the LRU algorithm<br>volatile-random -&gt; remove a random key with an expire set<br>allkeys-random -&gt; remove a random key, any key<br>volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)<br>noeviction -&gt; don’t expire at all, just return an error on write operations</p><p>Note: with any of the above policies, Redis will return an error on write<br>      operations, when there are no suitable keys for eviction.</p><pre><code>At the date of writing these commands are: set setnx setex appendincr decr rpush lpush rpushx lpushx linsert lset rpoplpush saddsinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrbyzunionstore zinterstore hset hsetnx hmset hincrby incrby decrbygetset mset msetnx exec sort</code></pre><p>The default is:</p><p>maxmemory-policy noeviction</p><p>LRU and minimal TTL algorithms are not precise algorithms but approximated<br>algorithms (in order to save memory), so you can tune it for speed or<br>accuracy. For default Redis will check five keys and pick the one that was<br>used less recently, you can change the sample size using the following<br>configuration directive.</p><p>The default of 5 produces good enough results. 10 Approximates very closely<br>true LRU but costs a bit more CPU. 3 is very fast but not very accurate.</p><p>maxmemory-samples 5</p><p>############################## APPEND ONLY MODE ###############################</p><p>By default Redis asynchronously dumps the dataset on disk. This mode is<br>good enough in many applications, but an issue with the Redis process or<br>a power outage may result into a few minutes of writes lost (depending on<br>the configured save points).</p><p>The Append Only File is an alternative persistence mode that provides<br>much better durability. For instance using the default data fsync policy<br>(see later in the config file) Redis can lose just one second of writes in a<br>dramatic event like a server power outage, or a single write if something<br>wrong with the Redis process itself happens, but the operating system is<br>still running correctly.</p><p>AOF and RDB persistence can be enabled at the same time without problems.<br>If the AOF is enabled on startup Redis will load the AOF, that is the file<br>with the better durability guarantees.</p><p>Please check <a href="http://redis.io/topics/persistence" target="_blank" rel="noopener">http://redis.io/topics/persistence</a> for more information.</p><p>redis 默认每次更新操作后会在后台异步的把数据库镜像备份到磁盘，但该备份非常耗时，且备份不宜太频繁<br>redis 同步数据文件是按上面save条件来同步的<br>如果发生诸如拉闸限电、拔插头等状况,那么将造成比较大范围的数据丢失<br>所以redis提供了另外一种更加高效的数据库备份及灾难恢复方式<br>开启append only 模式后,redis 将每一次写操作请求都追加到appendonly.aof 文件中<br>redis重新启动时,会从该文件恢复出之前的状态。<br>但可能会造成 appendonly.aof 文件过大，所以redis支持BGREWRITEAOF 指令，对appendonly.aof重新整理,默认是不开启的。</p><p>appendonly no</p><p>The name of the append only file (default: “appendonly.aof”)<br>默认为appendonly.aof。<br>appendfilename “appendonly.aof”</p><p>The fsync() call tells the Operating System to actually write data on disk<br>instead of waiting for more data in the output buffer. Some OS will really flush<br>data on disk, some other OS will just try to do it ASAP.</p><p>Redis supports three different modes:</p><p>no: don’t fsync, just let the OS flush the data when it wants. Faster.<br>always: fsync after every write to the append only log. Slow, Safest.<br>everysec: fsync only one time every second. Compromise.</p><p>The default is “everysec”, as that’s usually the right compromise between<br>speed and data safety. It’s up to you to understand if you can relax this to<br>“no” that will let the operating system flush the output buffer when<br>it wants, for better performances (but if you can live with the idea of<br>some data loss consider the default persistence mode that’s snapshotting),<br>or on the contrary, use “always” that’s very slow but a bit safer than<br>everysec.</p><p>More details please check the following article:<br><a href="http://antirez.com/post/redis-persistence-demystified.html" target="_blank" rel="noopener">http://antirez.com/post/redis-persistence-demystified.html</a></p><p>If unsure, use “everysec”.</p><p>设置对 appendonly.aof 文件进行同步的频率,有三种选择always、everysec、no，默认是everysec表示每秒同步一次。<br>always 表示每次有写操作都进行同步,everysec 表示对写操作进行累积,每秒同步一次。<br>no表示等操作系统进行数据缓存同步到磁盘，都进行同步,everysec 表示对写操作进行累积,每秒同步一次<br>appendfsync always<br>appendfsync everysec<br>appendfsync no</p><p>When the AOF fsync policy is set to always or everysec, and a background<br>saving process (a background save or AOF log background rewriting) is<br>performing a lot of I/O against the disk, in some Linux configurations<br>Redis may block too long on the fsync() call. Note that there is no fix for<br>this currently, as even performing fsync in a different thread will block<br>our synchronous write(2) call.</p><p>In order to mitigate this problem it’s possible to use the following option<br>that will prevent fsync() from being called in the main process while a<br>BGSAVE or BGREWRITEAOF is in progress.</p><p>This means that while another child is saving, the durability of Redis is<br>the same as “appendfsync none”. In practical terms, this means that it is<br>possible to lose up to 30 seconds of log in the worst scenario (with the<br>default Linux settings).</p><p>If you have latency problems turn this to “yes”. Otherwise leave it as<br>“no” that is the safest pick from the point of view of durability.<br>指定是否在后台aof文件rewrite期间调用fsync，默认为no，表示要调用fsync（无论后台是否有子进程在刷盘）。Redis在后台写RDB文件或重写afo文件期间会存在大量磁盘IO，此时，在某些linux系统中，调用fsync可能会阻塞。<br>no-appendfsync-on-rewrite yes</p><p>Automatic rewrite of the append only file.<br>Redis is able to automatically rewrite the log file implicitly calling<br>BGREWRITEAOF when the AOF log size grows by the specified percentage.</p><p>This is how it works: Redis remembers the size of the AOF file after the<br>latest rewrite (if no rewrite has happened since the restart, the size of<br>the AOF at startup is used).</p><p>This base size is compared to the current size. If the current size is<br>bigger than the specified percentage, the rewrite is triggered. Also<br>you need to specify a minimal size for the AOF file to be rewritten, this<br>is useful to avoid rewriting the AOF file even if the percentage increase<br>is reached but it is still pretty small.</p><p>Specify a percentage of zero in order to disable the automatic AOF<br>rewrite feature.<br>指定Redis重写aof文件的条件，默认为100，表示与上次rewrite的aof文件大小相比，当前aof文件增长量超过上次afo文件大小的100%时，就会触发background rewrite。若配置为0，则会禁用自动rewrite<br>auto-aof-rewrite-percentage 100</p><p>指定触发rewrite的aof文件大小。若aof文件小于该值，即使当前文件的增量比例达到auto-aof-rewrite-percentage的配置值，也不会触发自动rewrite。即这两个配置项同时满足时，才会触发rewrite。<br>auto-aof-rewrite-min-size 64mb</p><p>An AOF file may be found to be truncated at the end during the Redis<br>startup process, when the AOF data gets loaded back into memory.<br>This may happen when the system where Redis is running<br>crashes, especially when an ext4 filesystem is mounted without the<br>data=ordered option (however this can’t happen when Redis itself<br>crashes or aborts but the operating system still works correctly).</p><p>Redis can either exit with an error when this happens, or load as much<br>data as possible (the default now) and start if the AOF file is found<br>to be truncated at the end. The following option controls this behavior.</p><p>If aof-load-truncated is set to yes, a truncated AOF file is loaded and<br>the Redis server starts emitting a log to inform the user of the event.<br>Otherwise if the option is set to no, the server aborts with an error<br>and refuses to start. When the option is set to no, the user requires<br>to fix the AOF file using the “redis-check-aof” utility before to restart<br>the server.</p><p>Note that if the AOF file will be found to be corrupted in the middle<br>the server will still exit with an error. This option only applies when<br>Redis will try to read more data from the AOF file but not enough bytes<br>will be found.<br>aof-load-truncated yes</p><p>################################ LUA SCRIPTING  ###############################</p><p>Max execution time of a Lua script in milliseconds.</p><p>If the maximum execution time is reached Redis will log that a script is<br>still in execution after the maximum allowed time and will start to<br>reply to queries with an error.</p><p>When a long running script exceeds the maximum execution time only the<br>SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be<br>used to stop a script that did not yet called write commands. The second<br>is the only way to shut down the server in the case a write command was<br>already issued by the script but the user doesn’t want to wait for the natural<br>termination of the script.</p><p>Set it to 0 or a negative value for unlimited execution without warnings.<br>一个Lua脚本最长的执行时间，单位为毫秒，如果为0或负数表示无限执行时间，默认为5000<br>lua-time-limit 5000</p><p>################################ REDIS CLUSTER  ###############################</p><p>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<br>WARNING EXPERIMENTAL: Redis Cluster is considered to be stable code, however<br>in order to mark it as “mature” we need to wait for a non trivial percentage<br>of users to deploy it in production.<br>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</p><p>Normal Redis instances can’t be part of a Redis Cluster; only nodes that are<br>started as cluster nodes can. In order to start a Redis instance as a<br>cluster node enable the cluster support uncommenting the following:</p><p>cluster-enabled yes</p><p>Every cluster node has a cluster configuration file. This file is not<br>intended to be edited by hand. It is created and updated by Redis nodes.<br>Every Redis Cluster node requires a different cluster configuration file.<br>Make sure that instances running in the same system do not have<br>overlapping cluster configuration file names.</p><p>cluster-config-file nodes-6379.conf</p><p>Cluster node timeout is the amount of milliseconds a node must be unreachable<br>for it to be considered in failure state.<br>Most other internal time limits are multiple of the node timeout.</p><p>cluster-node-timeout 15000</p><p>A slave of a failing master will avoid to start a failover if its data<br>looks too old.</p><p>There is no simple way for a slave to actually have a exact measure of<br>its “data age”, so the following two checks are performed:</p><p>1) If there are multiple slaves able to failover, they exchange messages<br>   in order to try to give an advantage to the slave with the best<br>   replication offset (more data from the master processed).<br>   Slaves will try to get their rank by offset, and apply to the start<br>   of the failover a delay proportional to their rank.</p><p>2) Every single slave computes the time of the last interaction with<br>   its master. This can be the last ping or command received (if the master<br>   is still in the “connected” state), or the time that elapsed since the<br>   disconnection with the master (if the replication link is currently down).<br>   If the last interaction is too old, the slave will not try to failover<br>   at all.</p><p>The point “2” can be tuned by user. Specifically a slave will not perform<br>the failover if, since the last interaction with the master, the time<br>elapsed is greater than:</p><p>  (node-timeout * slave-validity-factor) + repl-ping-slave-period</p><p>So for example if node-timeout is 30 seconds, and the slave-validity-factor<br>is 10, and assuming a default repl-ping-slave-period of 10 seconds, the<br>slave will not try to failover if it was not able to talk with the master<br>for longer than 310 seconds.</p><p>A large slave-validity-factor may allow slaves with too old data to failover<br>a master, while a too small value may prevent the cluster from being able to<br>elect a slave at all.</p><p>For maximum availability, it is possible to set the slave-validity-factor<br>to a value of 0, which means, that slaves will always try to failover the<br>master regardless of the last time they interacted with the master.<br>(However they’ll always try to apply a delay proportional to their<br>offset rank).</p><p>Zero is the only value able to guarantee that when all the partitions heal<br>the cluster will always be able to continue.</p><p>cluster-slave-validity-factor 10</p><p>Cluster slaves are able to migrate to orphaned masters, that are masters<br>that are left without working slaves. This improves the cluster ability<br>to resist to failures as otherwise an orphaned master can’t be failed over<br>in case of failure if it has no working slaves.</p><p>Slaves migrate to orphaned masters only if there are still at least a<br>given number of other working slaves for their old master. This number<br>is the “migration barrier”. A migration barrier of 1 means that a slave<br>will migrate only if there is at least 1 other working slave for its master<br>and so forth. It usually reflects the number of slaves you want for every<br>master in your cluster.</p><p>Default is 1 (slaves migrate only if their masters remain with at least<br>one slave). To disable migration just set it to a very large value.<br>A value of 0 can be set but is useful only for debugging and dangerous<br>in production.</p><p>cluster-migration-barrier 1</p><p>By default Redis Cluster nodes stop accepting queries if they detect there<br>is at least an hash slot uncovered (no available node is serving it).<br>This way if the cluster is partially down (for example a range of hash slots<br>are no longer covered) all the cluster becomes, eventually, unavailable.<br>It automatically returns available as soon as all the slots are covered again.</p><p>However sometimes you want the subset of the cluster which is working,<br>to continue to accept queries for the part of the key space that is still<br>covered. In order to do so, just set the cluster-require-full-coverage<br>option to no.</p><p>cluster-require-full-coverage yes</p><p>In order to setup your cluster make sure to read the documentation<br>available at <a href="http://redis.io" target="_blank" rel="noopener">http://redis.io</a> web site.</p><p>################################## SLOW LOG ###################################</p><p>The Redis Slow Log is a system to log queries that exceeded a specified<br>execution time. The execution time does not include the I/O operations<br>like talking with the client, sending the reply and so forth,<br>but just the time needed to actually execute the command (this is the only<br>stage of command execution where the thread is blocked and can not serve<br>other requests in the meantime).</p><p>You can configure the slow log with two parameters: one tells Redis<br>what is the execution time, in microseconds, to exceed in order for the<br>command to get logged, and the other parameter is the length of the<br>slow log. When a new command is logged the oldest one is removed from the<br>queue of logged commands.</p><p>The following time is expressed in microseconds, so 1000000 is equivalent<br>to one second. Note that a negative number disables the slow log, while<br>a value of zero forces the logging of every command.<br>slowlog-log-slower-than 10000</p><p>There is no limit to this length. Just be aware that it will consume memory.<br>You can reclaim memory used by the slow log with SLOWLOG RESET.<br>slowlog-max-len 128</p><p>################################ LATENCY MONITOR ##############################</p><p>The Redis latency monitoring subsystem samples different operations<br>at runtime in order to collect data related to possible sources of<br>latency of a Redis instance.</p><p>Via the LATENCY command this information is available to the user that can<br>print graphs and obtain reports.</p><p>The system only logs operations that were performed in a time equal or<br>greater than the amount of milliseconds specified via the<br>latency-monitor-threshold configuration directive. When its value is set<br>to zero, the latency monitor is turned off.</p><p>By default latency monitoring is disabled since it is mostly not needed<br>if you don’t have latency issues, and collecting data has a performance<br>impact, that while very small, can be measured under big load. Latency<br>monitoring can easily be enabled at runtime using the command<br>“CONFIG SET latency-monitor-threshold <milliseconds>“ if needed.<br>latency-monitor-threshold 0</milliseconds></p><p>############################# EVENT NOTIFICATION ##############################</p><p>Redis can notify Pub/Sub clients about events happening in the key space.<br>This feature is documented at <a href="http://redis.io/topics/notifications" target="_blank" rel="noopener">http://redis.io/topics/notifications</a></p><p>For instance if keyspace events notification is enabled, and a client<br>performs a DEL operation on key “foo” stored in the Database 0, two<br>messages will be published via Pub/Sub:</p><p>PUBLISH <strong>keyspace@0</strong>:foo del<br>PUBLISH <strong>keyevent@0</strong>:del foo</p><p>It is possible to select the events that Redis will notify among a set<br>of classes. Every class is identified by a single character:</p><p> K     Keyspace events, published with <strong>keyspace@<db></db></strong> prefix.<br> E     Keyevent events, published with <strong>keyevent@<db></db></strong> prefix.<br> g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, …<br> $     String commands<br> l     List commands<br> s     Set commands<br> h     Hash commands<br> z     Sorted set commands<br> x     Expired events (events generated every time a key expires)<br> e     Evicted events (events generated when a key is evicted for maxmemory)<br> A     Alias for g$lshzxe, so that the “AKE” string means all the events.</p><p> The “notify-keyspace-events” takes as argument a string that is composed<br> of zero or multiple characters. The empty string means that notifications<br> are disabled.</p><p> Example: to enable list and generic events, from the point of view of the<br>          event name, use:</p><p> notify-keyspace-events Elg</p><p> Example 2: to get the stream of the expired keys subscribing to channel<br>            name <strong>keyevent@0</strong>:expired use:</p><p> notify-keyspace-events Ex</p><p> By default all notifications are disabled because most users don’t need<br> this feature and the feature has some overhead. Note that if you don’t<br> specify at least one of K or E, no events will be delivered.<br>notify-keyspace-events “”</p><p>############################### ADVANCED CONFIG ###############################</p><p>Hashes are encoded using a memory efficient data structure when they have a<br>small number of entries, and the biggest entry does not exceed a given<br>threshold. These thresholds can be configured using the following directives.<br>当hash中包含超过指定元素个数并且最大的元素没有超过临界时，<br>hash将以一种特殊的编码方式（大大减少内存使用）来存储，这里可以设置这两个临界值<br>hash-max-ziplist-entries 512<br>hash-max-ziplist-value 64</p><p>Similarly to hashes, small lists are also encoded in a special way in order<br>to save a lot of space. The special representation is only used when<br>you are under the following limits:<br>list数据类型多少节点以下会采用去指针的紧凑存储格式。<br>list数据类型节点值大小小于多少字节会采用紧凑存储格式。<br>list-max-ziplist-entries 512<br>list-max-ziplist-value 64</p><p>Sets have a special encoding in just one case: when a set is composed<br>of just strings that happen to be integers in radix 10 in the range<br>of 64 bit signed integers.<br>The following configuration setting sets the limit in the size of the<br>set in order to use this special memory saving encoding.<br>set数据类型内部数据如果全部是数值型，且包含多少节点以下会采用紧凑格式存储。<br>set-max-intset-entries 512</p><p>Similarly to hashes and lists, sorted sets are also specially encoded in<br>order to save a lot of space. This encoding is only used when the length and<br>elements of a sorted set are below the following limits:</p><p>zsort数据类型多少节点以下会采用去指针的紧凑存储格式。<br>zsort数据类型节点值大小小于多少字节会采用紧凑存储格式。<br>zset-max-ziplist-entries 128<br>zset-max-ziplist-value 64</p><p>HyperLogLog sparse representation bytes limit. The limit includes the<br>16 bytes header. When an HyperLogLog using the sparse representation crosses<br>this limit, it is converted into the dense representation.<br>#<br>A value greater than 16000 is totally useless, since at that point the<br>dense representation is more memory efficient.<br>#<br>The suggested value is ~ 3000 in order to have the benefits of<br>the space efficient encoding without slowing down too much PFADD,<br>which is O(N) with the sparse encoding. The value can be raised to<br>~ 10000 when CPU is not a concern, but space is, and the data set is<br>composed of many HyperLogLogs with cardinality in the 0 - 15000 range.<br>hll-sparse-max-bytes 3000</p><p>Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in<br>order to help rehashing the main Redis hash table (the one mapping top-level<br>keys to values). The hash table implementation Redis uses (see dict.c)<br>performs a lazy rehashing: the more operation you run into a hash table<br>that is rehashing, the more rehashing “steps” are performed, so if the<br>server is idle the rehashing is never complete and some more memory is used<br>by the hash table.</p><p>The default is to use this millisecond 10 times every second in order to<br>actively rehash the main dictionaries, freeing memory when possible.</p><p>If unsure:<br>use “activerehashing no” if you have hard latency requirements and it is<br>not a good thing in your environment that Redis can reply from time to time<br>to queries with 2 milliseconds delay.</p><p>use “activerehashing yes” if you don’t have such hard requirements but<br>want to free memory asap when possible.</p><p>Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用<br>当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。<br>如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存<br>activerehashing yes</p><p>The client output buffer limits can be used to force disconnection of clients<br>that are not reading data from the server fast enough for some reason (a<br>common reason is that a Pub/Sub client can’t consume messages as fast as the<br>publisher can produce them).</p><p>The limit can be set differently for the three different classes of clients:</p><p>normal -&gt; normal clients including MONITOR clients<br>slave  -&gt; slave clients<br>pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</p><p>The syntax of every client-output-buffer-limit directive is the following:</p><p>client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds></soft></soft></hard></class></p><p>A client is immediately disconnected once the hard limit is reached, or if<br>the soft limit is reached and remains reached for the specified number of<br>seconds (continuously).<br>So for instance if the hard limit is 32 megabytes and the soft limit is<br>16 megabytes / 10 seconds, the client will get disconnected immediately<br>if the size of the output buffers reach 32 megabytes, but will also get<br>disconnected if the client reaches 16 megabytes and continuously overcomes<br>the limit for 10 seconds.</p><p>By default normal clients are not limited because they don’t receive data<br>without asking (in a push way), but just after a request, so only<br>asynchronous clients may create a scenario where data is requested faster<br>than it can read.</p><p>Instead there is a default limit for pubsub and slave clients, since<br>subscribers and slaves receive data in a push fashion.</p><p>Both the hard or the soft limit can be disabled by setting them to zero.<br>client-output-buffer-limit normal 0 0 0<br>client-output-buffer-limit slave 256mb 64mb 60<br>client-output-buffer-limit pubsub 32mb 8mb 60</p><p>Redis calls an internal function to perform many background tasks, like<br>closing connections of clients in timeout, purging expired keys that are<br>never requested, and so forth.</p><p>Not all tasks are performed with the same frequency, but Redis checks for<br>tasks to perform according to the specified “hz” value.</p><p>By default “hz” is set to 10. Raising the value will use more CPU when<br>Redis is idle, but at the same time will make Redis more responsive when<br>there are many keys expiring at the same time, and timeouts may be<br>handled with more precision.</p><p>The range is between 1 and 500, however a value over 100 is usually not<br>a good idea. Most users should use the default of 10 and raise this up to<br>100 only in environments where very low latency is required.<br>hz 10</p><p>When a child rewrites the AOF file, if the following option is enabled<br>the file will be fsync-ed every 32 MB of data generated. This is useful<br>in order to commit the file to the disk more incrementally and avoid<br>big latency spikes.<br>aof rewrite过程中,是否采取增量文件同步策略,默认为“yes”。 rewrite过程中,每32M数据进行一次文件同步,这样可以减少aof大文件写入对磁盘的操作次数<br>aof-rewrite-incremental-fsync yes</p><p>redis数据存储<br>redis的存储分为内存存储、磁盘存储和log文件三部分，配置文件中有三个参数对其进行配置。<br>save seconds updates，save配置，指出在多长时间内，有多少次更新操作，就将数据同步到数据文件。可多个条件配合，默认配置了三个条件。<br>appendonly yes/no ，appendonly配置，指出是否在每次更新操作后进行日志记录，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面的save条件来同步的，所以有的数据会在一段时间内只存在于内存中。<br>appendfsync no/always/everysec ，appendfsync配置，no表示等操作系统进行数据缓存同步到磁盘，always表示每次更新操作后手动调用fsync()将数据写到磁盘，everysec表示每秒同步一次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;h1 id=&quot;redis配置详解&quot;&gt;&lt;a href=&quot;#redis配置详解&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Redis" scheme="https://iteverydaybro.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://iteverydaybro.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>redis-one</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/redis-one/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/redis-one/</id>
    <published>2019-10-31T15:16:16.000Z</published>
    <updated>2019-10-31T15:22:49.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><p>主要说明阿里云的Ubuntu系统2种方式配置redis数据库，远程访问的配置说明。</p><h1 id="apt-install"><a href="#apt-install" class="headerlink" title="apt install"></a>apt install</h1><p>1.apt-get update<br>2.apt-get install redis-server<br>3.whereis redis<br>4.cd /etc/redis<br>5.ls<br>6.vi redis.conf<br>:/daemonize  n查找下一个<br>设置成yes<br>:/bind n查找下一个<br>bind 0.0.0.0<br>:wq<br>7.cd ~<br>8.redis-server /etc/redis/redis.conf<br>9.netstat -anp | grep 6379<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hsk4glu6j30se01tt8o.jpg" alt><br>10.配置安全组<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hslh0hwsj31ff09swez.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hslz29mjj30ks0n33yy.jpg" alt><br>11.本地访问：telnet ip port<br>telnet 47.92.192.3 6379<br>ctrl+] quit<br>12.RedisDesktopManager<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hsnf8kcaj30sn04e3ym.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hsnfqeuxj30gi0ju0tn.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hsngp39qj309v0efdg9.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hsngsdbmj30l30a3dfx.jpg" alt></p><h1 id="安装包安装"><a href="#安装包安装" class="headerlink" title="安装包安装"></a>安装包安装</h1><p>1.下载地址：<a href="http://download.redis.io/releases/" target="_blank" rel="noopener">http://download.redis.io/releases/</a><br>2.wget <a href="http://download.redis.io/releases/redis-4.0.11.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-4.0.11.tar.gz</a><br>3.解压缩：tar    -zxvf redis-4.0.11.tar.gz 会在当前目录生成redis.4.0.11文件夹<br>4.如果没有安装gcc 需要安装下gcc  apt-get install gcc<br>5.cd 到redis.4.0.11<br>6.make<br>7.make install 会安装到/usr/local/bin下<br>8.配置redis.conf<br>9.redis-server /etc/redis/redis.conf</p><h1 id="至此配置完毕"><a href="#至此配置完毕" class="headerlink" title="至此配置完毕"></a>至此配置完毕</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;p&gt;主要说明阿里云的Ubuntu系统2种方式配置redis数据库，远程访问的配置说明。&lt;/p&gt;
&lt;h1 id=&quot;apt-inst
      
    
    </summary>
    
      <category term="Redis" scheme="https://iteverydaybro.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://iteverydaybro.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>abp-one</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/abp-one/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/abp-one/</id>
    <published>2019-10-31T15:12:45.000Z</published>
    <updated>2019-11-01T00:39:46.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><h1 id="Abp的搭建"><a href="#Abp的搭建" class="headerlink" title="Abp的搭建"></a>Abp的搭建</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;h1 id=&quot;Abp的搭建&quot;&gt;&lt;a href=&quot;#Abp的搭建&quot; class=&quot;headerlink&quot; title=&quot;Abp的搭
      
    
    </summary>
    
    
      <category term="Abp" scheme="https://iteverydaybro.github.io/tags/Abp/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-one</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/leetcode-one/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/leetcode-one/</id>
    <published>2019-10-31T15:05:46.000Z</published>
    <updated>2019-10-31T15:12:08.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the sameelement twice.<br>Example:<br>Given nums = [2, 7, 11, 15], target = 9,</p><p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p><h2 id="解体思路"><a href="#解体思路" class="headerlink" title="解体思路"></a>解体思路</h2><h2 id="解体方法"><a href="#解体方法" class="headerlink" title="解体方法"></a>解体方法</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0;i&lt;nums.Length;i++)&#123;</span><br><span class="line">for(var j=0;j&lt;nums.length;i++)&#123;</span><br><span class="line">if(nums[j]== target-nums[i])</span><br><span class="line">&#123;</span><br><span class="line">return new int[i,j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">throw new Exception(&quot;No two sum solution&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var ht = new Hashtable();</span><br><span class="line">for(var i=0;i&lt;nums.Length,i++)&#123;</span><br><span class="line">var result = target-nums[i];</span><br><span class="line">if(ht.ContainsKey(result)&#123;</span><br><span class="line">return new int[]&#123;(int)ht[result],i&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(!ht.containsKey(nums[i]))</span><br><span class="line">ht.Add(nums[i],i);</span><br><span class="line">&#125;</span><br><span class="line">throw new Exception(&quot;No two sum solution&quot;);</span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def twoSum(self,nums,target):</span><br><span class="line">for i in range(len(nums)):</span><br><span class="line">for j in range(i+1,len(nums)):</span><br><span class="line">if nums[j] == target - nums[i]:</span><br><span class="line">return [i,j]</span><br><span class="line">raise Exception(&quot;No two sum solution&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def towSum(self,nums,target):</span><br><span class="line">var result_dict = &#123;&#125;</span><br><span class="line">for i in range(len(nums)):</span><br><span class="line">if nums[i] in result_dict:</span><br><span class="line">return [result_dict[nums[i]],i]</span><br><span class="line">else:</span><br><span class="line">result_dict[target-nums[i]]=i</span><br><span class="line">raise Exception(&quot;No two sum solution&quot;)</span><br></pre></td></tr></table></figure><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums,int target)&#123;</span><br><span class="line">for(in i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">for(int j=i;j&lt;nums.length;j++)&#123;</span><br><span class="line">if(nums[j]==target-nums[i])&#123;</span><br><span class="line">return new int[]&#123;i,j&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">throw new IllegalArgumentException(&quot;No two sum solution&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums,int target)&#123;</span><br><span class="line">Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">map.put(nums[i],i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">int result = target-nums[i];</span><br><span class="line">if(map.ContainsKey(result)&amp;&amp;map.get(result)!=i)&#123;</span><br><span class="line">return new int[]&#123;i,map.get(result)&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">throw new IllegalArgumentExcetpion(&quot;No two sum solution&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums,int target)&#123;</span><br><span class="line">    Map&lt;Integer,Integert&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">        int result = target-nums[i];</span><br><span class="line">        if(map.ContainsKey(result))</span><br><span class="line">        return new int[]&#123;map.get(result),i&#125;;</span><br><span class="line">        map.put(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">throw new IllegalArgumentExcetption(&quot;No two sum solution&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;h1 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://iteverydaybro.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://iteverydaybro.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>http protocol one</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/http-protocol-one/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/http-protocol-one/</id>
    <published>2019-10-31T15:00:02.000Z</published>
    <updated>2019-10-31T15:10:45.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><h1 id="为什么学些HTTP协议"><a href="#为什么学些HTTP协议" class="headerlink" title="为什么学些HTTP协议"></a>为什么学些HTTP协议</h1><p>1.很多WEB开发真的不理解HTTP<br>2.HTTP真的很重要<br>3.提升自身价值</p><p>#<br>Redirect==》App cache ==&gt; DNS ==&gt; TCP ==&gt;Request ==&gt; Response</p><h1 id="网络协议层"><a href="#网络协议层" class="headerlink" title="网络协议层"></a>网络协议层</h1><p>经典五层模型：应用层（HTTP FTP）  传输层（TCP UDP）  网络层 数据链路层 物理层 客户端</p><p>物理层：主要作用是定义物理设备如何传输数据。<br>数据链路层：主要作用是在通信的实体间建立数据链路连接<br>网路层：主要作用是为数据在节点之间传输创建逻辑链路；<br>传输层：向用户提供可靠的端对端（End-to-End）的服务，传输层向高层屏蔽了下层数据通信的细节。<br>TCP/IP协议：<br>UDP协议<br>应用层：为应用软件提供了很多服务构建TCP协议之上，屏蔽网路传输相关细节。</p><h1 id="HTTP协议的发展历史"><a href="#HTTP协议的发展历史" class="headerlink" title="HTTP协议的发展历史"></a>HTTP协议的发展历史</h1><p>1.HTTP/0.9:只有一个GET请求 。  没有HEADER等描述数据的信息 。  服务器发送完毕，就关闭TCP连接。<br>2.HTTP/1.0:增加了很多命令 增加status code和header 多字符集支持 多部分发送 权限 缓存等<br>3.HTTP/1.1:持久连接 。 pipeline：发送多个请求 增加host和其他一些命令<br>4.HTTP2:所有数据以二进制传输  同一个连接里面发送多个请求不再需要按照顺序来<br>头信息压缩以及推送等提高效率的功能。</p><h1 id="TCP负责HTTP与服务器之间的连接"><a href="#TCP负责HTTP与服务器之间的连接" class="headerlink" title="TCP负责HTTP与服务器之间的连接"></a>TCP负责HTTP与服务器之间的连接</h1><p>三次握手：为了防止服务端开启无用的连接，规避因为网络延迟而导致的服务器的开销的问题。<br>winshark？网络抓包工具</p><p>URI：Uniform Resource Identifier/统一资源标志符 用来唯一标识互联网上的信息资源  包括URL和URN<br>URL：Uniform Resource Locator统一资源定位器<br>URN：永久统一资源定位符，在资源移动之后还鞥被找到，目前还没有成熟的解决方案。</p><h1 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h1><h2 id="请求报文："><a href="#请求报文：" class="headerlink" title="请求报文："></a>请求报文：</h2><p>首行：1.Method（GET POST DELETE等）2.请求地址 3.服务版本</p><h2 id="响应报文："><a href="#响应报文：" class="headerlink" title="响应报文："></a>响应报文：</h2><p>首行：1.版本2.Http Code</p><h2 id="HTTP方法：用来定义对资源的操作"><a href="#HTTP方法：用来定义对资源的操作" class="headerlink" title="HTTP方法：用来定义对资源的操作"></a>HTTP方法：用来定义对资源的操作</h2><p>常用的GET POST等 从定义上讲有各自的语义</p><h2 id="HTTP-CODE"><a href="#HTTP-CODE" class="headerlink" title="HTTP CODE"></a>HTTP CODE</h2><p>定义服务器对请求的处理结果 各个区间的CODE有各自的语义<br>好的HTTP服务可以通过CODE判断结果</p><h1 id="curl-帮助我们发送请求-返回请求结果"><a href="#curl-帮助我们发送请求-返回请求结果" class="headerlink" title="curl  帮助我们发送请求 返回请求结果"></a>curl  帮助我们发送请求 返回请求结果</h1><p>CORS 预请求<br>跨域允许的方法：GET HEAD POST<br>允许Content-type<br>text/plain<br>multipart/form-data<br>application/x-www-form-urlencoded<br>其他限制：<br>请求头的限制<br>XMLHttpRequestUpload对象均没有注册任何事件监听器<br>请求中没有使用ReadableStream对象</p><h1 id="缓存：可缓存性"><a href="#缓存：可缓存性" class="headerlink" title="缓存：可缓存性"></a>缓存：可缓存性</h1><p>public<br>private<br>no-cache：经过服务器端验证后，才能使用的<br>到期：<br>max-age=<seconds><br>s-maxage=<seconds><br>max-stale=<seconds><br>重新验证：<br>must-revalidate<br>proxy-revalidate<br>其他：<br>no-store：只能去服务器获取数据<br>no-transform：不允许改动返回的数据内容<br>缓存验证Last-Modified和Etag的使用</seconds></seconds></seconds></p><p>Etag：<br>数据签名：hash计算<br>配合If-Match或者If-Non-Match使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;h1 id=&quot;为什么学些HTTP协议&quot;&gt;&lt;a href=&quot;#为什么学些HTTP协议&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="HTTP Protocal" scheme="https://iteverydaybro.github.io/categories/HTTP-Protocal/"/>
    
    
      <category term="HTTP Protocol" scheme="https://iteverydaybro.github.io/tags/HTTP-Protocol/"/>
    
  </entry>
  
  <entry>
    <title>dotnet-core-one</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/dotnet-core-one/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/dotnet-core-one/</id>
    <published>2019-10-31T14:56:41.000Z</published>
    <updated>2019-10-31T15:10:58.841Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="DotNet Core" scheme="https://iteverydaybro.github.io/categories/DotNet-Core/"/>
    
    
      <category term="DotNet Core" scheme="https://iteverydaybro.github.io/tags/DotNet-Core/"/>
    
  </entry>
  
  <entry>
    <title>docker one</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/docker-one/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/docker-one/</id>
    <published>2019-10-31T14:49:45.000Z</published>
    <updated>2019-10-31T14:53:56.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h2><p>一种虚拟化的方案<br>操作系统级别的虚拟化<br>只能运行相同或者形似内核的操作系统<br>依赖于Linux内核特性：Namespace和Cgroups</p><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p>将应用程序自动部署到容器<br>Go语言开源引擎 GitHub地址：<a href="https://github.com/docker/docker" target="_blank" rel="noopener">https://github.com/docker/docker</a><br>2013年初 dotCloud<br>基于Apache 2.0 开源授权协议发行</p><h2 id="Docker目标"><a href="#Docker目标" class="headerlink" title="Docker目标"></a>Docker目标</h2><p>提供简单轻量的建模方式<br>职责的逻辑分离<br>快速高效的开发生命周期<br>鼓励使用面向服务的架构</p><h2 id="Docker使用场景"><a href="#Docker使用场景" class="headerlink" title="Docker使用场景"></a>Docker使用场景</h2><p>使用Docker容器开发 测试 部署服务<br>创建隔离的运行环境<br>搭建测试环境<br>构建多用化的平台即服务（Paas）基础设施<br>高性能 超大规模的宿主机部署</p><h2 id="Docker基本组成"><a href="#Docker基本组成" class="headerlink" title="Docker基本组成"></a>Docker基本组成</h2><h3 id="1-Docker-Client-客户端-守护进程"><a href="#1-Docker-Client-客户端-守护进程" class="headerlink" title="1.Docker Client 客户端/守护进程"></a>1.Docker Client 客户端/守护进程</h3><p>C/S架构<br>本地/远程</p><h3 id="Docker-Image-镜像"><a href="#Docker-Image-镜像" class="headerlink" title="Docker Image 镜像"></a>Docker Image 镜像</h3><p>容器的基石<br>层叠的只读文件系统<br>联合加载（union mount）</p><h3 id="Docker-Container-容器"><a href="#Docker-Container-容器" class="headerlink" title="Docker Container 容器"></a>Docker Container 容器</h3><p>通过镜像启动<br>启动和执行阶段<br>写时复制（copy to write）</p><h3 id="Docker-Registry-仓库"><a href="#Docker-Registry-仓库" class="headerlink" title="Docker Registry 仓库"></a>Docker Registry 仓库</h3><p>公有<br>私有<br>Docker Hub<br>Docker 在线演示地址：<a href="https://www.docker.com/tryit" target="_blank" rel="noopener">https://www.docker.com/tryit</a><br><a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></p><h2 id="Docke容器相关技术简介"><a href="#Docke容器相关技术简介" class="headerlink" title="Docke容器相关技术简介"></a>Docke容器相关技术简介</h2><h3 id="Docker依赖的Linux内核特性"><a href="#Docker依赖的Linux内核特性" class="headerlink" title="Docker依赖的Linux内核特性"></a>Docker依赖的Linux内核特性</h3><h4 id="Namespace命名空间"><a href="#Namespace命名空间" class="headerlink" title="Namespace命名空间"></a>Namespace命名空间</h4><p>编程语言==》封装==〉代码隔离<br>操作系统==》系统资源的隔离==〉进程 网络 文件系统<br>1.PID（Process ID）进程隔离<br>2.NET（Network）管理网络接口<br>3.IPC（InterProcess Communication）管理夸进程通信的访问<br>4.MNT（Mount）管理挂载点<br>5.UTS（Unix Timesharing System）隔离内核和版本标识</p><h4 id="Control-groups（cgroups）控制组"><a href="#Control-groups（cgroups）控制组" class="headerlink" title="Control groups（cgroups）控制组"></a>Control groups（cgroups）控制组</h4><p>用来分配资源<br>来源于Google<br>Linux kernel 2.6.24 @2007<br>1.资源限制<br>2.优先级设定<br>3.资源计量<br>4.资源控制</p><h4 id="Docker-容器的能力"><a href="#Docker-容器的能力" class="headerlink" title="Docker 容器的能力"></a>Docker 容器的能力</h4><p>1.文件系统隔离：每个容器都有自己的root文件系统<br>2.进程隔离：每个容器都运行在自己的进程环境中<br>3.网络隔离：容器间的虚拟网络接口和IP地址都是分开的<br>4.资源隔离和分组：使用cgroups将CPU和内存之类的资源独立分配给每个Docker容器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;h1 id=&quot;Docker简介&quot;&gt;&lt;a href=&quot;#Docker简介&quot; class=&quot;headerlink&quot; title=&quot;D
      
    
    </summary>
    
      <category term="Docker" scheme="https://iteverydaybro.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://iteverydaybro.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>company-one</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/company-one/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/company-one/</id>
    <published>2019-10-31T14:43:43.000Z</published>
    <updated>2019-11-01T00:39:46.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><p>推荐给大家一些程序员接单平台</p><h1 id="程序员客栈"><a href="#程序员客栈" class="headerlink" title="程序员客栈"></a>程序员客栈</h1><p><a href="https://www.proginn.com" target="_blank" rel="noopener">https://www.proginn.com</a></p><h1 id="码市"><a href="#码市" class="headerlink" title="码市"></a>码市</h1><p><a href="https://codemart.com" target="_blank" rel="noopener">https://codemart.com</a></p><h1 id="开源众包"><a href="#开源众包" class="headerlink" title="开源众包"></a>开源众包</h1><p><a href="https://zb.oschina.net" target="_blank" rel="noopener">https://zb.oschina.net</a></p><h1 id="快码"><a href="#快码" class="headerlink" title="快码"></a>快码</h1><p><a href="https://www.kuai.ma/" target="_blank" rel="noopener">https://www.kuai.ma/</a></p><h1 id="码易"><a href="#码易" class="headerlink" title="码易"></a>码易</h1><p><a href="https://www.mayigeek.com/" target="_blank" rel="noopener">https://www.mayigeek.com/</a></p><h1 id="一早一晚"><a href="#一早一晚" class="headerlink" title="一早一晚"></a>一早一晚</h1><p><a href="https://3cwork.com" target="_blank" rel="noopener">https://3cwork.com</a></p><h1 id="stack-overflow"><a href="#stack-overflow" class="headerlink" title="stack overflow"></a>stack overflow</h1><p><a href="https://stackoverflow.com/" target="_blank" rel="noopener">https://stackoverflow.com/</a></p><h1 id="Dribbble"><a href="#Dribbble" class="headerlink" title="Dribbble:"></a>Dribbble:</h1><p><a href="https://dribbble.com" target="_blank" rel="noopener">https://dribbble.com</a></p><h1 id="Up-works"><a href="#Up-works" class="headerlink" title="Up works"></a>Up works</h1><p><a href="https://www.upwork.com/" target="_blank" rel="noopener">https://www.upwork.com/</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><a href="https://shixian.com" target="_blank" rel="noopener">https://shixian.com</a></p><h1 id="猿急送"><a href="#猿急送" class="headerlink" title="猿急送"></a>猿急送</h1><p><a href="https://www.yuanjisong.com" target="_blank" rel="noopener">https://www.yuanjisong.com</a></p><h1 id="xsoft"><a href="#xsoft" class="headerlink" title="xsoft"></a>xsoft</h1><p><a href="https://www.sxsoft.com/" target="_blank" rel="noopener">https://www.sxsoft.com/</a></p><h1 id="人人开发"><a href="#人人开发" class="headerlink" title="人人开发"></a>人人开发</h1><p><a href="http://rrkf.com" target="_blank" rel="noopener">http://rrkf.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;p&gt;推荐给大家一些程序员接单平台&lt;/p&gt;
&lt;h1 id=&quot;程序员客栈&quot;&gt;&lt;a href=&quot;#程序员客栈&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Company" scheme="https://iteverydaybro.github.io/categories/Company/"/>
    
    
      <category term="Company" scheme="https://iteverydaybro.github.io/tags/Company/"/>
    
  </entry>
  
  <entry>
    <title>cmd batch two</title>
    <link href="https://iteverydaybro.github.io/2019/10/31/cmd-bat-two/"/>
    <id>https://iteverydaybro.github.io/2019/10/31/cmd-bat-two/</id>
    <published>2019-10-31T14:05:36.000Z</published>
    <updated>2019-10-31T14:41:02.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h1><p>今天去部署IIS的时候发现其中一个端口被占用了，但是不知道是是什么程序/服务占用了端口，所以需要查找下是哪个程序/服务占用了端口，然后kill掉程序，特此记录一下。</p><h2 id="部署到IIS的Web站点启动不起来，很有可能其端口号被占用了"><a href="#部署到IIS的Web站点启动不起来，很有可能其端口号被占用了" class="headerlink" title="部署到IIS的Web站点启动不起来，很有可能其端口号被占用了"></a>部署到IIS的Web站点启动不起来，很有可能其端口号被占用了</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hqnv36jwj31io0tqwo6.jpg" alt></p><h2 id="我们需要利用netstat-ano命令去查找端口占用情况"><a href="#我们需要利用netstat-ano命令去查找端口占用情况" class="headerlink" title="我们需要利用netstat -ano命令去查找端口占用情况"></a>我们需要利用netstat -ano命令去查找端口占用情况</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hqrsbq2uj31hc098gnt.jpg" alt></p><h2 id="利用taskkill-F-PID-去杀掉进程"><a href="#利用taskkill-F-PID-去杀掉进程" class="headerlink" title="利用taskkill /F /PID 去杀掉进程"></a>利用taskkill /F /PID 去杀掉进程</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hqw1wrupj30p203w0tg.jpg" alt></p><h1 id="netstat-命令介绍"><a href="#netstat-命令介绍" class="headerlink" title="netstat 命令介绍"></a>netstat 命令介绍</h1><p>Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接等</p><h2 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h2><p>-a 显示所有选项，默认不显示LISTEN相关信息<br>-t 仅显示tcp相关信息<br>-n 拒绝显示别名，能显示数字的全部转换为数字<br>-p 显示建立相关链接的程序名<br>-r 显示路由信息，路由表<br>-e 显示扩展信息，例如uid等<br>-s 按各个协议进行统计</p><h3 id="netstat-a"><a href="#netstat-a" class="headerlink" title="netstat -a"></a>netstat -a</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hrd2m6h7j310q0pijy3.jpg" alt></p><h3 id="netstat-t"><a href="#netstat-t" class="headerlink" title="netstat -t"></a>netstat -t</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hrdq3ondj31go0iqn5y.jpg" alt></p><h3 id="netstat-n"><a href="#netstat-n" class="headerlink" title="netstat -n"></a>netstat -n</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hretm7ubj31ho0m0gzi.jpg" alt></p><h3 id="netstat-r"><a href="#netstat-r" class="headerlink" title="netstat -r"></a>netstat -r</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hrg4hvv1j30zi0kk46i.jpg" alt></p><h3 id="netstat-e"><a href="#netstat-e" class="headerlink" title="netstat -e"></a>netstat -e</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hrgifjomj30qc0ak3zu.jpg" alt></p><h3 id="netstat-s"><a href="#netstat-s" class="headerlink" title="netstat -s"></a>netstat -s</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8hrgyzstrj310k0mogpq.jpg" alt></p><h1 id="taskkill-命令介绍"><a href="#taskkill-命令介绍" class="headerlink" title="taskkill 命令介绍"></a>taskkill 命令介绍</h1><h2 id="常见参数-1"><a href="#常见参数-1" class="headerlink" title="常见参数"></a>常见参数</h2><h3 id="IM-根据进程名称终止进程"><a href="#IM-根据进程名称终止进程" class="headerlink" title="/IM 根据进程名称终止进程"></a>/IM 根据进程名称终止进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /IM executablename</span><br></pre></td></tr></table></figure><h3 id="F-强制终止进程"><a href="#F-强制终止进程" class="headerlink" title="/F 强制终止进程"></a>/F 强制终止进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /F /IM iexplore.exe</span><br></pre></td></tr></table></figure><h3 id="PID-根据进程ID终止进程"><a href="#PID-根据进程ID终止进程" class="headerlink" title="/PID 根据进程ID终止进程"></a>/PID 根据进程ID终止进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">taskkill /PID  processId</span><br><span class="line">taskkill /PID 1234</span><br></pre></td></tr></table></figure><h3 id="FI-终止消耗大量内存的进程"><a href="#FI-终止消耗大量内存的进程" class="headerlink" title="/FI 终止消耗大量内存的进程"></a>/FI 终止消耗大量内存的进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">taskkill /FI &quot;memusage gt value&quot;</span><br><span class="line">taskkill /FI &quot;memusage gt 102400&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;本文说明&quot;&gt;&lt;a href=&quot;#本文说明&quot; class=&quot;headerlink&quot; title=&quot;本文说明&quot;&gt;&lt;/a&gt;本文说明&lt;/h1&gt;&lt;p&gt;今天去部署IIS的时候发现其中一个端口被占用了，但是不知道是是什么程序/服务占用了端口，所以需要查找下是哪个程序/服务占用了
      
    
    </summary>
    
      <category term="CMD Batch" scheme="https://iteverydaybro.github.io/categories/CMD-Batch/"/>
    
    
      <category term="CMD Batch" scheme="https://iteverydaybro.github.io/tags/CMD-Batch/"/>
    
  </entry>
  
</feed>
